#!/usr/bin/php -q
<?php

	define('APPLICATION_ROOT', realpath(dirname(__FILE__)));

	$_SERVER['DOCUMENT_ROOT']  = (isset($argv[1]))
		? realpath($argv[1])
		: dirname(__FILE__);

	$_SERVER['REQUEST_URI']    = '/';
	$_SERVER['REQUEST_METHOD'] = 'GET';
	$_SERVER['REMOTE_ADDR']    = '127.0.0.1';
	$_SERVER['SERVER_NAME']    = 'localhost';

	////////////////////////////////////////////////////////////////////////////
	// The following block of code is unique to inKWell, if you want to use
	// this terminal for something else, delete it.
	////////////////////////////////////////////////////////////////////////////

	chdir(implode(DIRECTORY_SEPARATOR, array(
		dirname(__FILE__),
		'includes'
	)));

	require 'init.php';

	// Set some basics regardless of configuration

	fCore::enableErrorHandling('html');
	fCore::enableExceptionHandling('html');

	////////////////////////////////////////////////////////////////////////////
	// End inKWell Specific Code
	////////////////////////////////////////////////////////////////////////////

	$___stdin   = fopen('php://stdin', 'r');
	$___depth   = 0;
	$___line    = 0;
	$___code    = '\?';
	$___command = '';

	echo PHP_EOL;
	echo 'Welcome to the inKWell Console, you can begin typing PHP or try:';
	echo PHP_EOL;
	echo PHP_EOL;

	do {

		$___code = trim($___code);

		if ($___code && $___code[0] == '\\') {
			switch ($___trigger = substr($___code, 0, 2)) {
				case '\q':
					$___called_quit = TRUE;
					exit();
					break;
				case '\c':
				case '\e':
				case '\?':
				case '\>':
				default:
					switch ($___trigger) {
						case '\c':
							passthru('clear');
							break;
						case '\?':
							echo '\q - Quit the Program'         . PHP_EOL;
							echo '\c - Clear the Screen'         . PHP_EOL;
							echo '\e - Execute a System Command' . PHP_EOL;
							echo '\> - Change Directory'         . PHP_EOL;
							echo '\? - Display this Message'     . PHP_EOL;
							echo PHP_EOL;
							break;
						case '\e':
							if (!($___exec = trim(substr($___code, 2)))) {
								echo 'Please enter a Command: ';
								$___exec = trim(fgets($___stdin));
							}
							passthru($___exec);
							break;
						case '\>':
							if (!($___directory = trim(substr($___code, 2)))) {
								echo 'Please enter a Directory: ';
								$___directory = trim(fgets($___stdin));
							}
							chdir(trim($___directory, '\'"'));
							break;
					}

					$___code    = '';
					$___line--;

					break;
			}
		}

		$___command  .= $___code . PHP_EOL;

		foreach (token_get_all('<?php ' . $___code) as $___token) {
			if (!is_array($___token)) {
				switch ($___token) {
					case '{':
					case '(':
						$___depth++;
						break;
					case '}':
					case ')':
						$___depth--;
						break;
				}
			}
		}

		if ($___depth <= 0) {

			$___depth = 0;
			$___line  = 0;

			if ($___command && ___check($___command)) {

				ob_start();

				fCore::startErrorCapture();
				try {
					eval($___command);
				} catch (fException $___e) {
					echo 'Exception:  ' . $___e->getMessage();
				}

				if(is_array($errors = fCore::stopErrorCapture())) {
					foreach ($errors as $error) {
						echo $error['type'] . ':  ' . $error['string'];
					}
				}

				$___output  = ob_get_clean();

				if($___output) {
					echo $___output;
					echo PHP_EOL;
				}
			}

			$___command = '';
		}

		$___line++;
		echo '[' . getcwd() . '][' . sprintf('%02s', $___line) . ']# ';

	} while(($___code = fgets($___stdin)));

	/**
	 * Register as a shutdown function to ensure that any fatal errors or
	 * uncaught exceptions do not terminate the shell.  This function
	 * will cause it to respawn itself on shutdown.  The only downside is
	 * that all previous variables and information are lost.
	 *
	 * @param void
	 * @return void
	 */
	function ___respawn()
	{
		echo ob_get_clean() . "\n";

		if (!isset($GLOBALS['___called_quit'])) {
			echo "Resetting...\n";
			passthru(__FILE__);
		}
	}

	// Register the respawn shutdown function

	register_shutdown_function('___respawn');

	/**
	 * Check syntax and other validity aspects of PHP source code.
	 *
	 * @param string $string A string of PHP source code without an open tag
	 * @return boolean TRUE if code appears valid, FALSE otherwise
	 */
	function ___check($string)
	{
		$source       = '<?php ' . $string;
		$syntax_check = shell_exec(sprintf(
			'echo %s | php -l',
			escapeshellarg($source)
		));

		if (stripos($syntax_check, 'No syntax errors') === FALSE) {
			return FALSE;
		}

		foreach (($tokens = token_get_all($source)) as $i => $token) {

			if (is_array($token)) {

				if ($token[0] == T_STRING && $tokens[$i + 1] == '(') {

					$t      = $token[1];
					$c      = 1;
					$method = NULL;

					do {

						$previous_token = is_array($tokens[$i - $c])
							? $tokens[$i - $c][0]
							: $tokens[$i - $c];

						$c++;

					} while($previous_token == T_WHITESPACE);

					switch ($previous_token) {

						// Safe Cases

						case T_FUNCTION:
						case T_OBJECT_OPERATOR:
							break;

						case T_PAAMAYIM_NEKUDOTAYIM:

							$t      = $tokens[$i - 2][1];
							$method = $token[1];

						case T_NEW:

							if (!class_exists($t)) {
								echo sprintf(
									'Error:  Class %s does not exist.',
									$t
								) . PHP_EOL;
								return FALSE;
							}

							// Handle method_exists check for static methods

							if (isset($method) && !method_exists($t, $method)) {
								echo sprintf(
									'Error:  Method %s() does not exist on %s.',
									$method,
									$t
								) . PHP_EOL;
								return FALSE;
							}

							break;

						default:

							if (!function_exists($t)) {
								echo sprintf(
									'Error:  Function %s() does not exist.',
									$t
								) . PHP_EOL;
								return FALSE;
							}
							break;
					}
				}
			}
		}

		return TRUE;
	}
