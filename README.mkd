# inKWell (MVC Framework and CMS)

## Preamble

At the moment the stock CMS (usually part of the Admin Section) is in shambles.
Do not expect it to work right.  In the mean time however feel free to use
inKWell as a basic framework.

## Licensing

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU Affero General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.

If you wish to license this software under different terms and conditions,
please e-mail: Matthew J. Sahagian <msahagian@dotink.org>

## Introduction

inKWell is an MVC framework built on Flourish (http://www.flourishlib.com) and
Moor (http://www.github.com/jeffturcotte/moor).  It is designed to be extremely
light weight and flexible.  Unlike other frameworks nearly every aspect of it
is designed to allow for easy overrides, including scaffolding.

The core framework follows a "KISS" philosophy.  We begin by keeping core
concepts and API to a minimum, providing only six classes in that comprise
the base framework, while everything else is an extension.

Nearly all aspects of integration start with a configuration file and a
single method on all your classes: __init().  The complexity of what you write
is completely up to you.  Because our core libraries, including Flourish offer
a nice set of hooks, __init() is all you need to provide full integration with
everything else.

The core classes are as follows (and will be explained later):

1. IW (Contains only the basic framework functionality, mainly autoloading)
2. ActiveRecord (An advanced active record/model class built on fActiveRecord)
3. RecordSet (A wrapper for multiple ActiveRecords built on fRecordSet)
4. View (A standard view/templating engine built on fTemplating)
5. Controller (A simple controller with common triggers)
6. Scaffolder (A scaffolder which supports templating)

## Configuration

inKWell uses a modular configuration system where files are mapped one to one
to a configuration key.  With the exception of those configuration files used
to initialize inkwell itself, all configuration files are named after the
underscorized version of your class names.

When your classes are autoloaded, the inKWell autoloader will take their
particular configuration section and pass them to the static __init() method
found on your class.  You are then responsible for setting up your class,
registering any hooks you'd like, etc, based on the configuration information.

Let's take a look at an example from inkwell itself.  Below is the configuration
file for our Controller class ('includes/config/classes/controller.php' by
default):

	return array(

		// The standard controller class allows for errors to be custom
		// configured based on keys.  Controller::triggerError('not_found')
		// for example would use the information provided by the 'not_found'
		// key below.
		//
		// Custom error configurations are expected to be arrays containing
		// the following key => value pairs:
		//
		//      'handler'  : A custom callback to handle the error
		//      'header'   : A header to be sent when triggered
		//      'messsage' : A default error message
		//
		// Errors which are not configured will fallback to using
		// Controller::triggerHardError() with default 500 internal server
		// error headers and a generic message

		'errors'             => array(
			'not_found'      => array(
				'handler'    => 'PagesController::notFound',
				'header'     => 'HTTP/1.0 404 Not Found',
				'message'    => 'The requested resource could not be found'
			),
			'not_authorized' => array(
				'handler'    => 'AuthController::login',
				'header'     => 'HTTP/1.0 401 Not Authorized',
				'message'    => 'The requested resource requires authorization'
			),
			'forbidden'      => array(
				'handler'    => 'PagesController::forbidden',
				'header'     => 'HTTP/1.0 403 Forbidden',
				'message'    => 'You do not have permission to view the requested resource'
			)
		)
	);

As you can see from the above example, our core configuration file contains
normal, executable php code.  Using nicely nested arrays and some commenting
there is no need for additional parsers of third party object/data formats as
is found in some other frameworks.  When controller is called, this
configuration information is passed into it's __init() function which registers
the error events based on the information.  How we chose to register them,
what methods we use, etc, are completely up to us.

Some things are currently not configurable in the controller but could be, for
example, the default request format type which is currently html.  If we so
chose, we could easily add a 'default_request_format' key to our array, and
modify our __init() to set that directly or even use an externally accessible
API like Controller::setDefaultRequestFormat()...  however we decide to do it,
it remains 100% up to us, the developer.
